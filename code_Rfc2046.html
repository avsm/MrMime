<html><head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="MrMime" rel="Chapter" href="MrMime.html">
<link title="Newline" rel="Chapter" href="Newline.html">
<link title="Date" rel="Chapter" href="Date.html">
<link title="LiteralDomain" rel="Chapter" href="LiteralDomain.html">
<link title="Address" rel="Chapter" href="Address.html">
<link title="MsgID" rel="Chapter" href="MsgID.html">
<link title="Resent" rel="Chapter" href="Resent.html">
<link title="Trace" rel="Chapter" href="Trace.html">
<link title="MimeVersion" rel="Chapter" href="MimeVersion.html">
<link title="ContentType" rel="Chapter" href="ContentType.html">
<link title="ContentEncoding" rel="Chapter" href="ContentEncoding.html">
<link title="Content" rel="Chapter" href="Content.html">
<link title="Header" rel="Chapter" href="Header.html">
<link title="Message" rel="Chapter" href="Message.html">
<link title="Option" rel="Chapter" href="Option.html">
<link title="Iana" rel="Chapter" href="Iana.html">
<link title="Error" rel="Chapter" href="Error.html">
<link title="Decoder" rel="Chapter" href="Decoder.html">
<link title="BaseDecoder" rel="Chapter" href="BaseDecoder.html">
<link title="Encoder" rel="Chapter" href="Encoder.html">
<link title="BaseEncoder" rel="Chapter" href="BaseEncoder.html">
<link title="Wrap" rel="Chapter" href="Wrap.html">
<link title="Rfc6532" rel="Chapter" href="Rfc6532.html">
<link title="Rfc822" rel="Chapter" href="Rfc822.html">
<link title="Rfc5321" rel="Chapter" href="Rfc5321.html">
<link title="Rfc5322" rel="Chapter" href="Rfc5322.html">
<link title="Rfc6854" rel="Chapter" href="Rfc6854.html">
<link title="Rfc2045" rel="Chapter" href="Rfc2045.html">
<link title="Base64" rel="Chapter" href="Base64.html">
<link title="QuotedPrintable" rel="Chapter" href="QuotedPrintable.html">
<link title="Rfc2046" rel="Chapter" href="Rfc2046.html">
<link title="Rfc2047" rel="Chapter" href="Rfc2047.html">
<link title="Grammar" rel="Chapter" href="Grammar.html"><title>Rfc2046</title>
</head>
<body>
<code class="code">open BaseDecoder

let is_bcharsnospace = function
  | '\'' | '(' | ')' | '+' | '_' | ','
  | '-' | '.' | '/' | ':' | '=' | '?' -> true
  | 'a' .. 'z' | 'A' .. 'Z' -> true
  | '0' .. '9' -> true
  | _ -> false

let is_bchars = function
  | ' ' -> true
  | chr -> is_bcharsnospace chr

let is_valid_bchars str =
  let i = ref 0 in

  while !i < String.length str
        && is_bchars (String.get str !i)
  do incr i done;

  !i = String.length str

let p_dash_boundary boundary p =
  p_str "--"
  @ p_str boundary
  @ p

let m_dash_boundary boundary =
  "--" ^ boundary

let p_transport_padding p =
  [%debug Printf.printf "state: p_transport_padding\n%!"];

  (0 * 0) (function '\x09' | '\x20' -> true | _ -> false)
  @ fun _ state -> [%debug Printf.printf "state: p_transport_padding end\n%!"]; p state

(* See RFC 2046 § 5.1.1:

   discard-text := *( *text CRLF) *text
                   ; May be ignored or discarded.

   and RFC 822 § 3.3:

   text        =  <any CHAR, including bare    ; => atoms, specials,
                   CR & bare LF, but NOT       ;  comments and
                   including CRLF>             ;  quoted-strings are
                                               ;  NOT recognized.
*)
let p_discard_text stop p =
  let rec text has_text state =
    let rec aux = function
      | `Stop state -> p has_text state
      | `Read (buf, off, len, k) ->
        `Read (buf, off, len, (fun i -> aux @@ safe k i))
      | #Error.err as err ->  err
      | `Continue state ->
        (cur_chr @ function
         | chr -> junk_chr @ text true)
        state
    in aux @@ safe (stop has_text) state
  in

  text false

(* See RFC 2046 § 5.1.1:

   preamble := discard-text
   epilogue := discard-text
*)
let p_preamble stop p state = p_discard_text stop p state
let p_epilogue stop p state = p_discard_text stop p state

(* See RFC 2046 § 5.1.1:

   delimiter := CRLF dash-boundary

   XXX: need to be compose with [dash-boundary]
*)
let p_delimiter boundary p =
  Rfc822.p_crlf @ p_dash_boundary boundary p

let m_delimiter boundary =
  "\r\n" ^ (m_dash_boundary boundary)

let p_close_delimiter boundary p =
  [%debug Printf.printf "state: p_close_delimiter %s\n%!" boundary];

  p_delimiter boundary
  @ p_str "--"
  @ (fun state -> [%debug Printf.printf "state: p_close_delimiter match\n%!"]; p state)

let m_close_delimiter boundary =
  (m_delimiter boundary) ^ "--"

(* See RFC 2046 § 5.1:

   body-part := MIME-part-headers [CRLF *OCTET]
                ; Lines in a body-part must not start
                ; with the specified dash-boundary and
                ; the delimiter must not appear anywhere
                ; in the body part.  Note that the
                ; semantics of a body-part differ from
                ; the semantics of a message, as
                ; described in the text.

   XXX: [p_octet] must be stop to the boundary
*)
let p_body_part (type data) boundary p_octet p =
  [%debug Printf.printf "state: p_body_part\n%!"];

  let next fields =
    (Rfc822.p_crlf
     @ p_octet fields
     @ fun data state -> `Ok ((data : data), state))
    / (p None)
    @ (fun data -> p (Some (data : data)))
  in

  (Rfc2045.p_mime_part_headers
     (fun field next state -> raise (Error.Error (Error.err_invalid_field field state)))
     (Rfc5322.p_field @ fun field _ state -> raise (Error.Error (Error.err_invalid_field field state)))
     (fun fields state -> `Ok (fields, state)))
  / (next [])
  @ next

(* See RFC 2046 § 5.1.1:

   encapsulation := delimiter transport-padding
                    CRLF body-part
*)
let p_encapsulation boundary p_octet p state =
  [%debug Printf.printf "state: p_encapsulation\n%!"];

  (p_delimiter boundary
   @ p_transport_padding @ Rfc822.p_crlf @ p_body_part boundary p_octet p)
  state

(* See RFC 2046 § 5.1.1:

   multipart-body := [preamble CRLF]
                     dash-boundary transport-padding CRLF
                     body-part *encapsulation
                     close-delimiter
                     transport-padding
                     [CRLF epilogue]
*)
let p_multipart_body boundary parent_boundary p_octet p =
  [%debug Printf.printf "state: p_multipart [boundary: %s and parent boundary: %s]\n%!"
   boundary
   (match parent_boundary with Some x -> x | None -> "<none>")];

  let stop_preamble has_text =
    let dash_boundary = m_dash_boundary boundary in
    p_try_rule
      (fun () state ->
       roll_back
         (fun state -> `Stop state)
         dash_boundary
         state)
      (fun state -> `Continue state)
      (p_dash_boundary boundary (fun state-> `Ok ((), state)))
  in
  let stop_epilogue state =
    [%debug Printf.printf "state: p_multipart (stop epilogue)\n%!"];

    match parent_boundary with
    | None ->
      [%debug Printf.printf "state: p_multipart (stop epilogue) to end\n%!"];

      (fun state -> match peek_chr state with
       | None -> `Ok ((), state)
       | Some chr -> raise (Error.Error (Error.err_unexpected chr state)))
      / (fun state -> `Continue state)
      @ (fun () state -> `Stop state)
    | Some boundary ->
      let delimiter = m_delimiter boundary in
      let close_delimiter = m_close_delimiter boundary in
      p_try_rule
        (fun () -> roll_back (fun state -> `Stop state) close_delimiter)
        (p_try_rule
           (fun () -> roll_back (fun state -> `Stop state) delimiter)
           (fun state -> `Continue state)
           (p_delimiter boundary (fun state -> `Ok ((), state))))
        (p_close_delimiter boundary (fun state -> [%debug Printf.printf "state: p_multipart (stop epilogue) close delimiter\n%!"]; `Ok ((), state)))
  in
  let rec next acc =
    [%debug Printf.printf "state: p_multipart/next\n%!"];

    (* XXX: according to RFC 2046, we have a CRLF rule just before epilogue.
            but we can have a parent boundary just after the current boundary
            like that:

            CRLF
            --foo--CRLF
            --barCRLF

            so if we force the CRLF just before epilogue, we consume the CRLF
            needed by the parent delimiter and we consider [--bar] as the
            epilogue. It's false, so we don't check the required CRLF of
            epilogue and nobody cares about the epilogue. *)
    (p_encapsulation boundary p_octet @ fun data state -> `Ok (data, state))
    / (p_close_delimiter boundary
       @ (u_repeat (function '\x09' | '\x20' -> true | _ -> false))
       @ fun _ ->
         (p_epilogue stop_epilogue
          @ fun _ -> ok ())
         / (p (List.rev acc))
         @ fun () -> p (List.rev acc))
    @ fun data -> next (data :: acc)
  in

  p_preamble stop_preamble
  @ fun has_preamble ->
    p_dash_boundary boundary
    @ p_transport_padding
    @ Rfc822.p_crlf
    @ p_body_part boundary p_octet
    @ fun data -> next [data]
</code></body></html>