<html><head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Input" rel="Chapter" href="Input.html">
<link title="Parser" rel="Chapter" href="Parser.html">
<link title="Encoder" rel="Chapter" href="Encoder.html">
<link title="Wrap" rel="Chapter" href="Wrap.html">
<link title="Rfc6532" rel="Chapter" href="Rfc6532.html">
<link title="Rfc822" rel="Chapter" href="Rfc822.html">
<link title="Rfc2045" rel="Chapter" href="Rfc2045.html">
<link title="Base64" rel="Chapter" href="Base64.html">
<link title="QuotedPrintable" rel="Chapter" href="QuotedPrintable.html">
<link title="Rfc2047" rel="Chapter" href="Rfc2047.html">
<link title="Rfc5321" rel="Chapter" href="Rfc5321.html">
<link title="Rfc5322" rel="Chapter" href="Rfc5322.html">
<link title="Rfc2046" rel="Chapter" href="Rfc2046.html">
<link title="Top" rel="Chapter" href="Top.html">
<link title="Date" rel="Chapter" href="Date.html">
<link title="MsgID" rel="Chapter" href="MsgID.html">
<link title="MimeVersion" rel="Chapter" href="MimeVersion.html">
<link title="ContentEncoding" rel="Chapter" href="ContentEncoding.html">
<link title="ContentType" rel="Chapter" href="ContentType.html">
<link title="Content" rel="Chapter" href="Content.html">
<link title="Address" rel="Chapter" href="Address.html">
<link title="Resent" rel="Chapter" href="Resent.html">
<link title="Trace" rel="Chapter" href="Trace.html">
<link title="Header" rel="Chapter" href="Header.html">
<link title="Message" rel="Chapter" href="Message.html"><title>Rfc2046</title>
</head>
<body>
<code class="code">let locate buff off len f =
  let idx = ref 0 in
  while !idx < len && f (Internal_buffer.get buff (off + !idx))
  do incr idx done;

  !idx

open Parser
open Parser.Convenience

let is_bcharsnospace = function
  | '\'' | '(' | ')' | '+' | '_' | ','
  | '-' | '.' | '/' | ':' | '=' | '?' -> true
  | 'a' .. 'z' | 'A' .. 'Z' -> true
  | '0' .. '9' -> true
  | _ -> false

let is_bchars = function
  | ' ' -> true
  | c -> is_bcharsnospace c

let make_dash_boundary boundary =
  "--" ^ boundary

let make_delimiter boundary =
  "\r\n" ^ (make_dash_boundary boundary)

let make_close_delimiter boundary =
  (make_delimiter boundary) ^ "--"

(* XXX: you can rollback just after. *)
let dash_boundary boundary =
  let string s = string (fun x -> x) s in
  string ("--" ^ boundary) *> return ()

let discard_to_dash_boundary boundary =
  (fix @@ fun m ->
   { f = fun i s fail succ ->
     let discard buff off len = locate buff off len ((<>) '-') in

     let n = Input.transmit i discard in
     succ i s n } *> peek_chr >>= function
   | Some '-' -> (dash_boundary boundary
                  *> return true) <|> (advance 1 *> m)
   | Some chr -> m
   | None -> return false)
  >>= fun has_boundary ->
     { f = fun i s fail succ ->

       if has_boundary
       then Input.rollback i (Internal_buffer.from_string ~proof:(Input.proof i) @@ "--" ^ boundary);
       succ i s () }


let transport_padding =
  repeat None None (function '\x09' | '\x20' -> true | _ -> false)

let text =
  fix @@ fun m ->
    { f = fun i s fail succ ->
      let discard buff off len = locate buff off len ((=) '\r') in

      let n = Input.transmit i discard in
      succ i s n } *> peek_chr >>= function
    | None -> return ()
    | Some '\r' ->
      (advance 1 *> peek_chr >>= function
       | None -> return ()
       | Some '\n' ->
         { f = fun i s fail succ ->
           Input.rollback i (Internal_buffer.from_string ~proof:(Input.proof i) "\r");

           succ i s () }
       | _ -> m)
    | _ -> m

let discard_text =
  let many p = fix (fun m -> (p *> m) <|> return ()) in
  many (many text *> Rfc822.crlf) *> many text

(* XXX: you can rollback just after. *)
let delimiter boundary =
  let string s = string (fun x -> x) s in
  string ("\r\n--" ^ boundary) *> return ()

(* XXX: you can rollback just after. *)
let close_delimiter boundary =
  delimiter (boundary ^ "--") *> return ()

let discard_to_delimiter boundary =
  (fix @@ fun m ->
   { f = fun i s fail succ ->
     let discard buff off len = locate buff off len ((<>) '\r') in
     let n = Input.transmit i discard in
     succ i s n } *> peek_chr >>= function
   | Some '\r' -> (delimiter boundary
                   *> return true) <|> (advance 1 *> m)
   | Some chr -> m
   | None -> return false)
  >>= fun has_boundary ->
     let f
       : 'r 'input. (('r, 'input) fail -> ('a, 'r, 'input) success -> ('r, 'input) state, 'input) k
       = fun i s fail succ ->

         if has_boundary
         then Input.rollback i (Internal_buffer.from_string ~proof:(Input.proof i) ("\r\n--" ^ boundary));
         succ i s ()
     in { f }

let body_part octet =
  Rfc2045.mime_part_headers
    (Rfc5322.field (fun _ -> fail Rfc5322.Nothing_to_do))
  >>= Content.part >>= fun (content, fields) ->
    option None (Rfc822.crlf *> octet content fields >>| fun v -> Some v)
  >>| fun octets -> (content, fields, octets)

let encapsulation boundary octet =
  delimiter boundary
  *> transport_padding
  *> Rfc822.crlf
  *> body_part octet

let preamble boundary = discard_to_dash_boundary boundary
let epilogue parent = match parent with
  | Some boundary -> discard_to_delimiter boundary
  | None ->
    fix @@ fun m ->
    { f = fun i s fail succ ->
      let _ = Input.transmit i (fun _ _ len -> len) in
      succ i s () } *> peek_chr >>= function
    | None -> return ()
    | Some _ -> m

let multipart_body parent boundary octet =
  option () (preamble boundary)
  *> dash_boundary boundary
  *> transport_padding
  *> Rfc822.crlf
  *> body_part octet
  >>= fun x -> many (encapsulation boundary octet)
  >>= fun r ->
    (close_delimiter boundary
     *> transport_padding
     *> option () (Rfc822.crlf *> (epilogue parent))
     *> return (x :: r)) <|> (return (x :: r))
</code></body></html>